<!doctype html>
<html>
  <body>
    <script>// ===== FULLSCREEN FRAGMENT SHADER BOILERPLATE (WebGL2) =====

// --- Canvas ---
const canvas = document.createElement("canvas");
document.body.style.margin = "0";
document.body.style.overflow = "clip"
document.body.appendChild(canvas);

const gl = canvas.getContext("webgl2");
if (!gl) {
  throw new Error("WebGL2 not supported");
}

// --- Resize ---
function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = innerWidth * dpr;
  canvas.height = innerHeight * dpr;
  canvas.style.width  = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();

// --- Vertex Shader (fixed) ---
const VERT_SRC = `#version 300 es
in vec2 position;
void main() {
  gl_Position = vec4(position, 0.0, 1.0);
}
`;

// ----------------------------------------------------------
// ðŸ”´ PASTE YOUR FRAGMENT SHADER HERE
// (must be #version 300 es and write to out vec4)
// ----------------------------------------------------------
const FRAG_SRC = `#version 300 es
#define MY_HIGHP_OR_MEDIUMP highp

precision highp float;
precision highp int;
precision highp sampler2D;
uniform float u_time;
uniform vec2 u_resolution;
float vort_speed = 0.5;
vec4 colour_2 = vec4(0,0.6156862745098,1,1);
vec4 colour_1 = vec4(0.9907843137255,0.37254901960784,0.3333333333333,1);
float mid_flash = 0.0;
float vort_offset;
vec2 uv;
float randTime = 1765656902.0;

out vec4 out_color; 

#define PIXEL_SIZE_FAC 700.
#define BLACK 0.6*vec4(79./255.,99./255., 103./255., 1./0.6)

vec4 effect( vec2 screen_coords ) {
  vort_offset = mod((2.0*90.15315131*randTime),100000.0);
  //Convert to UV coords (0-1) and floor for pixel effect
  MY_HIGHP_OR_MEDIUMP float pixel_size = length(u_resolution)/PIXEL_SIZE_FAC;
  MY_HIGHP_OR_MEDIUMP vec2 uv = ((floor(screen_coords.xy*(1./pixel_size))*pixel_size - 0.5*u_resolution)/length(u_resolution));
  MY_HIGHP_OR_MEDIUMP float uv_len = length(uv);
  //Adding in a center swirl, changes with u_time
  MY_HIGHP_OR_MEDIUMP float speed = float(u_time*vort_speed);//
  MY_HIGHP_OR_MEDIUMP float new_pixel_angle = (atan(-uv.y, uv.x) + (2.2 + 0.4f*min(6.0,speed))*uv_len - 1.0 -  speed*0.05f - min(6.0,speed)*speed*0.02 + vort_offset);
  MY_HIGHP_OR_MEDIUMP vec2 mid = (u_resolution/length(u_resolution))/2.;
  MY_HIGHP_OR_MEDIUMP vec2 sv = vec2((uv_len * cos(new_pixel_angle) + mid.x), (uv_len * sin(new_pixel_angle) + mid.y)) - mid;
  //Now add the smoke effect to the swirled UV
  sv *= 30.;
  speed = u_time*(6.0)*vort_speed + vort_offset + 1033.0;
  MY_HIGHP_OR_MEDIUMP vec2 uv2 = vec2(sv.x+sv.y);
  for(int i=0; i < 5; i++) {
    uv2 += sin(max(sv.x, sv.y)) + sv;
    sv  += 0.5*vec2(cos(5.1123314 + 0.353*uv2.y + speed*0.131121),sin(uv2.x - 0.113*speed));
    sv  -= 1.0*cos(sv.x + sv.y) - 1.0*sin(sv.x*0.711 - sv.y);
  }

  //Make the smoke amount range from 0 - 2
  MY_HIGHP_OR_MEDIUMP float smoke_res =min(2., max(-2., 1.5 + length(sv)*0.12 - 0.17*(min(10.0,u_time*1.2 - 4.))));
  if (smoke_res < 0.2) {
    smoke_res = (smoke_res - 0.2)*0.6 + 0.2;
  }
    
  MY_HIGHP_OR_MEDIUMP float c1p = max(0.,1. - 2.*abs(1.-smoke_res));
  MY_HIGHP_OR_MEDIUMP float c2p = max(0.,1. - 2.*(smoke_res));
  MY_HIGHP_OR_MEDIUMP float cb = 1. - min(1., c1p + c2p);

  MY_HIGHP_OR_MEDIUMP vec4 ret_col = colour_1*c1p + colour_2*c2p + vec4(cb*BLACK.rgb, cb*colour_1.a);
  MY_HIGHP_OR_MEDIUMP float mod_flash = max(mid_flash*0.8, max(c1p, c2p)*5. - 4.4) + mid_flash*max(c1p, c2p);

  return ret_col*(1. - mod_flash) + mod_flash*vec4(1., 1., 1., 1.);
}
void main(){
  out_color = effect(gl_FragCoord.xy);
}
`;
// ----------------------------------------------------------

// --- Shader Compile ---
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error("Shader compile failed");
  }
  return s;
}

// --- Program ---
const program = gl.createProgram();
gl.attachShader(program, compile(gl.VERTEX_SHADER, VERT_SRC));
gl.attachShader(program, compile(gl.FRAGMENT_SHADER, FRAG_SRC));
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error(gl.getProgramInfoLog(program));
  throw new Error("Program link failed");
}
gl.useProgram(program);

// --- Fullscreen Triangle ---
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([
    -1, -1,
     3, -1,
    -1,  3
  ]),
  gl.STATIC_DRAW
);

const posLoc = gl.getAttribLocation(program, "position");
gl.enableVertexAttribArray(posLoc);
gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

// --- Uniform Locations ---
const timeLoc = gl.getUniformLocation(program, "u_time");
const resLoc  = gl.getUniformLocation(program, "u_resolution");

// --- Render Loop ---
function render(t) {
  gl.uniform1f(timeLoc, t * 0.001);
  gl.uniform2f(resLoc, canvas.width, canvas.height);

  gl.drawArrays(gl.TRIANGLES, 0, 3);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
  </body>
</html>
